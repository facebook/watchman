#!/usr/bin/env python
from __future__ import print_function
import pywatchman
import argparse
import os
import sys
import time
import json


def fieldlist(s):
    # helper for splitting a list of fields by comma
    return s.split(',')


parser = argparse.ArgumentParser(
    formatter_class=argparse.RawDescriptionHelpFormatter,
    description="""
watchman-replicate-subscription can replicate an existing watchman
subscription. It queries watchman for a list of subscriptions, identifies the
source subscription (i.e., the subscription to replicate) and subscribes to watchman
using the same query.

Integrators can use this client to validate the watchman notifications their
client is receiving to localize anomalous behavior.

The source subscription is identified using any combination of the 'name',
'pid', and 'client' arguments. The provided combination must uniquely identify
a subscription. Source subscription details for a watched root can be
retrieved by running the command 'watchman-replicate-subscription PATH --list'.

By default, the replicated subscription will take the source subscription
name and prepend the substring 'replicate: ' to it. The 'qname' option can be
used to specify the replicated subscription name.

The subscription can stop after a configurable number of events are observed.
The default is a single event. You may also remove the limit and allow it to
execute continuously.

watchman-replicate-subscription will print one event per line. The event
information is determined by the fields in the identified subscription, with
each field separated by a space (or your choice of --separator).

Events are consolidated and settled by the watchman server before they are
dispatched to watchman-replicate-subscription.

Exit Status:

The following exit status codes can be used to determine what caused
watchman-wait to exit:

0  After successfully waiting for event(s) or listing matching subscriptions
1  In case of a runtime error of some kind
2  The -t/--timeout option was used and that amount of time passed
   before an event was received
3  Execution was interrupted (Ctrl-C)

""")
parser.add_argument('path', type=str,
                    help="""
The path to a watched root whose subscription we'd like to replicate. The list
of watched roots can be retrieved by running 'watchman watch-list'.
""")
parser.add_argument('-s', '--separator', type=str, default=' ',
                    help='String to use as field separator for event output.')
parser.add_argument('-q', '--qname', type=str, default=None,
                    help="""
The replicated subscription name. The default will be the source subscription
with the string 'replicate: ' prepended to it.
""")
parser.add_argument('-n', '--name', type=str, default=None,
                    help="""
The name of the subscription to replicate.
""")
parser.add_argument('-c', '--client', type=str, default=None,
                    help="""
The client id of the subscription to replicate.
""")
parser.add_argument('-p', '--pid', type=str, default=None,
                    help="""
The process id of the subscription to replicate.
""")
parser.add_argument('-m', '--max-events', type=int, default=1,
                    help="""
Set the maximum number of events that will be processed.  When the limit
is reached, watchman-replicate-subscription exit.  The default is 1.  Setting
the limit to 0 removes the limit, causing watchman-wait to execute indefinitely.
""")
parser.add_argument('-t', '--timeout', type=float, default=0, help="""
Exit if no events trigger within the specified timeout.  If timeout is
zero (the default) then keep running indefinitely.
""")
parser.add_argument('-l', '--list', action='store_true', help="""
Print the matching subscription list and exit.
""")
parser.add_argument('-f', '--full', action='store_true', help="""
Use with '--list' to print complete subscription information, including the
query.
""")
args = parser.parse_args()

# Running total of individual file events we've seen
total_events = 0


class Subscription(object):
    root = None     # Watched root
    name = None     # Our name for this subscription
    path = None

    def __init__(self, path, name, query):
        self.name = name
        self.query = query
        self.path = os.path.abspath(path)
        if not os.path.exists(self.path):
            print(
                'path %s (%s) does not exist.' %
                (path, self.path), file=sys.stderr)
            sys.exit(1)

    def __repr__(self):
        return 'Subscription(path=%s, name=%s, query=%s)' % (
            self.path, self.name, json.dumps(self.query))

    def start(self, client):
        watch = client.query('watch-project', self.path)
        if 'warning' in watch:
            print('WARNING: ', watch['warning'], file=sys.stderr)
        self.root = watch['watch']

        # get the initial clock value so that we only get updates
        self.query['since'] = client.query('clock', self.root)['clock']
        sub = client.query('subscribe', self.root, self.name, self.query)

    def formatField(self, fname, val):
        return str(val)

    def emit(self, client):
        global total_events
        data = client.getSubscription(self.name)
        if data is None:
            return False
        for dat in data:
            for f in dat.get('files', []):
                out = []
                if len(repFields) == 1:
                    # When only 1 field is specified, the result is a
                    # list of just the values
                    out.append(self.formatField(repFields[0], f))
                else:
                    # Otherwise it is a list of objects
                    for fname in repFields:
                        out.append(self.formatField(fname, f[fname]))
                print(args.separator.join(out))
                sys.stdout.flush()
                total_events = total_events + 1
                if args.max_events > 0 and total_events >= args.max_events:
                    sys.exit(0)
        return True


def getSubIdInfo(subName, subClient, subPid):
    return '(name=\'%s\', pid=\'%s\' client=\'%s\')' % (
        "Any" if subName is None else subName,
        "Any" if subPid is None else subPid,
        "Any" if subClient is None else subClient
    )


def getSubInfo(sub,keys=None):
    rslt = {}
    if keys is None:
        keys = ['name', 'pid', 'client', 'query']
    subInfo = sub['info'] if 'info' in sub else {}
    for key in keys:
        if key in subInfo:
            rslt[key] = subInfo[key]
        else:
            rslt[key] = ''
            keyWarn = true
    return rslt


path = args.path
subName = args.name
subPid = args.pid
subClient = args.client
client = pywatchman.client()

# We use debug-get-subscriptions to get subscription information.  Note:
# the debug commands are not stable/supported, so we are susceptible to breakage
# if they change.  Do not copy this approach without understanding this risk.
subs = client.query('debug-get-subscriptions', path)
matchSubs = []
for sub in subs['subscribers']:
    info = sub['info']
    if (subName is None or sub['info']['name'] == subName) and (
        subPid is None or str(sub['info']['pid']) == subPid
    ) and (subClient is None or str(sub['info']['client']) == subClient):
        matchSubs.append(sub)

if args.list:
    if len(matchSubs) == 0:
        print('No matching subscriptions')
    for sub in matchSubs:
        keys = None if args.full else ['name', 'pid', 'client']
        print(json.dumps(getSubInfo(sub, keys=keys), indent=2), file=sys.stdout)
    sys.exit(0)

if len(matchSubs) == 0:
    print(
        'Error, no matching subscriptions:\n'
        '\tcriteria: %s\n'
        '\tpath: %s\n'
        'To get a list of subscriptions for a watched root, use:\n'
        '\twatchman-replicate-subscription PATH --list' %
        (getSubIdInfo(subName, subClient, subPid), path), file=sys.stderr
    )
    sys.exit(1)

if len(matchSubs) > 1:
    print(
        'Error, found multiple matching subscriptions:\n'
        '\tcriteria: %s\n'
        '\tpath: %s\n'
        'Use the \'--name\', \'--client\' and \'--pid\' options to identify a subscription.\n'
        'To get a list of subscriptions for a watched root, use:\n'
        '\twatchman-replicate-subscription PATH --list' %
        (getSubIdInfo(subName, subClient, subPid), path), file=sys.stderr
    )
    sys.exit(1)

matchSub = matchSubs[0]
repQuery = matchSubs[0]['info']['query']
repFields = matchSubs[0]['info']['query']['fields']
repName = args.qname if args.qname else "replicate: " + \
    matchSub['info']['name']

repSub = Subscription(name=repName, path=path, query=repQuery)
print("%s" % (repSub))

deadline = None
if args.timeout > 0:
    deadline = time.time() + args.timeout

try:
    repSub.start(client)

except pywatchman.CommandError as ex:
    print('watchman:', ex.msg, file=sys.stderr)
    sys.exit(1)

while deadline is None or time.time() < deadline:
    try:
        if deadline is not None:
            client.setTimeout(deadline - time.time())
        # wait for a unilateral response
        result = client.receive()

        # in theory we can parse just the result variable here, but
        # the client object will accumulate all subscription results
        # over time, so we ask it to remove and return those values
        # for each of the subscriptions
        repSub.emit(client)

    except pywatchman.SocketTimeout as ex:
        if deadline is not None and time.time() >= deadline:
            sys.exit(2)

        # Let's check to see if we're still functional
        try:
            vers = client.query('version')
        except Exception as ex:
            print('watchman:', str(ex), file=sys.stderr)
            sys.exit(1)

    except KeyboardInterrupt:
        # suppress ugly stack trace when they Ctrl-C
        sys.exit(3)
